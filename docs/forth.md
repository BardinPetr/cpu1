## Язык Forth

Конкатенативный язык программирования, основанный на стековой модели вычисления
и имеющий оформление в обратной польской нотации.

### Грамматика в форме Бэкуса-Наура:

<details>
<summary>Листинг</summary>
Здесь специально представлены отдельно термы парсера и лексера, именно так это реализовано в коде.

```bnf
// parser, program is root
program ::= program | definition | function | command


function ::= FUNC_BEGIN WORD func_body FUNC_END
func_body ::= func_body | command | if_expr | for_expr | do_while_expr | while_expr


if_expr ::= COND_IF func_body COND_THEN | COND_IF func_body COND_ELSE func_body COND_THEN
for_expr ::= FOR_BEGIN func_body FOR_END
do_while_expr ::= WHILE_BEGIN func_body WHILE_END
while_expr ::= WHILE_BEGIN func_body WHILE_COND func_body WHILE_REPEAT

definition ::= def_const | def_arr | def_var
def_arr ::= def_var NUMBER MEM_CELLS MEM_ALLOC
def_const ::= NUMBER DEF_CONST WORD
def_var ::= DEF_VAR WORD

command ::= cmd_call | cmd_io_str | cmd_push | cmd_str
cmd_push ::= NUMBER
cmd_call ::= WORD
cmd_io_str ::= IO_OUT_STR
cmd_str ::= CONST_STR


// lexer

FUNC_BEGIN ::= ":"
FUNC_END ::= ";"

COND_IF ::= "if"
COND_ELSE ::= "else"
COND_THEN ::= "then"

FOR_BEGIN ::= "do"
FOR_END ::= "loop"

WHILE_BEGIN ::= "begin"
WHILE_END ::= "until"
WHILE_REPEAT ::= "repeat"
WHILE_COND ::= "while"

MEM_ALLOC ::= "allot"

DEF_CONST ::= "constant"
DEF_VAR ::= "variable"

IO_OUT_STR ::= ".\""
CONST_STR ::= "s\""

PAREN_L ::= "("
PAREN_R ::= ")"
COMMENT ::= "\\"
NUMBER ::= r"\d+"
WORD ::= r"[\w!#$%&*+,./<=>?@^_|~-]+"
```

</details>

### Принцип работы

- команды языка исполняются последовательно
- 2 типа элементов языка
    - слова (исполняемые команды), к ним относится все, включая встроенные операции и любые вызовы
    - определения функций и переменных
- литералы только целочисленные и представляют собой push в стек
- функции (слова)
    - calling convention:
        - входные данные на D-стеке
        - выходные данные на D-стеке
    - процесс вызова
        - переход по относительному смещению с сохранением адреса возврата в R-стеке
        - возврат по адресу из R-стека
- доступны циклы и условные операторы
- доступны переменные, константы, массивы и строки
- нет меток, goto и иных подобных способов внешне управлять процессом вычисления
- подробнее в последующих разделах

### Типы данных

Физическое представление имеется только для одного типа данных:

- int: целочисленный, знаковый, 32 бит
    - все математические операции
    - все операции со стеком
    - иные слова использующие данные стека и системных регистров
    - всегда представлен одним 32-битным словом в памяти

Также есть вспомогательные типы данных, которые напрямую использованы быть не могут

- short: целочисленный, знаковый, 16 бит
    - формат транспортный, только для immediate операндов в системе команд процессора
    - используется для целочисленных литералов, так как они транслируются в PUSH immediate операнда

- bool: 1 бит (32 бит)
    - false=0, true=1
    - всегда занимает одно слово

- char: 8 бит (32 бит)
    - всегда занимает одно слово

- string
    - не имеет физического представления
    - строка в памяти хранится последовательностью:
        - 1 int определяющий длину
        - далее содержимое, char
    - формат указателя - int, на ячейку длины
    - хранятся всегда в памяти

- array
    - массивы определяются как последовательность ячеек памяти и не имеют отдельного интерфейса.

### Области видимости

Все forth-слова доступны только после их определения, иначе не допустимо.

- переменные
    - только глобальные
    - доступны глобально сразу после определения
- функции
    - только глобальные, вложенность запрещена
    - доступны глобально сразу после определения
    - рекурсия доступна с определенными ранее функциями и данной функцией

### Встроенные слова

Примеры работы есть в [тестовых сценариях](test/golden/golden_def).

- использование управляющих структур доступно только в функциях

<details>
<summary>Определения слов</summary>

#### Литералы

```
<number> ( -- number )                  \ PUSH в стек D значения number
```

#### Определение переменных

```
variable <name>                         \ определение переменной размером в одно int слово           
variable <name> <num> cells allot       \ определение переменной-массива размером <num>+1.
<name>                                  \ получение адреса переменной или начала массива
```

#### Определение констант

Константы только для типа int, и всегда заменяются на литералы при трансляции

```
<value> constant <name>                
```

#### Определение строк

Строка всегда определяется ее указателем.

```
s" <text>" ( -- addr )                  \ создание строки, размещение ее в памяти и возврат указателя

\ Типичный способ определения и использования строки для переиспользования ее
: string-hw  s" Hello world!" ;         
string-hw type
```

#### Определение собственного слова:

```
 : <name> <body> ;    \ определение
 <name>               \ вызов слова
```

#### Оператор if, if-else

Определение: [ForthTransformer.if_expr](src/compiler/transformer.py)

```
 if <body> then ( val -- )              \ исполнение <body> если val == 1 
 if <true> else <false> then ( val -- ) \ исполнение <true> если val == 1 иначе <false>
```

#### Цикл for

Определение: [ForthTransformer.for_expr](src/compiler/transformer.py)

```
do <body> loop ( from to -- )           \ вызов <body> от from включитлеьно до to не включительно 
i ( -- cur )                            \ получить итератор текущий цикла последнего по вложенности 
```

#### Цикл while

Определение: [ForthTransformer.while_expr](src/compiler/transformer.py)

```
begin <cond> while <body> repeat        \ вызов <cond>, взятие значения со стека, при значении =1 переход к <body> затем в начало 
```

#### Цикл do-while

Определение: [ForthTransformer.do_while_expr](src/compiler/transformer.py)

```
begin <body> until                      \ вызов <body>, взятие значения со стека, при значении =0 переход в начало 
```

</details>

#### Встроенные слова

Способ трансляции описан в [stdlib.py](src/compiler/forthlib/stdlib.py)

Библиотека ввода-вывода в [iolib.fth](src/compiler/forthlib/iolib.fth)

<details>
<summary>Листинг</summary>

Список слов, для которых напрямую определена трансляция в команды процессора.

```
 +       ( n1 n2 -- n1+n2 )
 -       ( n1 n2 -- n1-n2 )
 *       ( n1 n2 -- n1*n2 )   \ Signed multiplication
 /       ( n1 n2 -- n1/n2 )   \ Signed division
 mod     ( n1 n2 -- n1%n2 )   \ Modulo operator
 and     ( n1 n2 -- n1&n2 )   \ Bitwise and
 or      ( n1 n2 -- n1|n2 )   \ Bitwise or
 invert  ( n -- ~n )          \ Bitwise logical inversion
 negate  ( n -- -n )          \ Arithmetic negation, 0-n
 1-      ( n -- n-1 )         \ Decrement by 1
 1+      ( n -- n+1 )         \ Increment by 1  
 
 \ Data stack manipulation
 dup  ( a -- a a )
 drop ( a -- )
 swap ( a b -- b a )
 over ( a b -- a b a )
 
 \ Memory ops
 @  ( adr -- l )             \ Fetch a 32-bit value
 !  ( l adr -- )             \ Store a 32-bit value
 +!  ( l adr -- )            \ Increase by l a 32-bit value
 
 \ Comparison ops 
 =    ( n1 n2 -- flag )  \ True if n1 = n2
 <>   ( n1 n2 -- flag )  \ True if n1 != n2
 <    ( n1 n2 -- flag )  \ True if n1 < n2  (signed)
 >    ( n1 n2 -- flag )  \ True if n1 > n2  (signed)
 u<   ( u1 u2 -- flag )  \ True if n1 < n2  (unsigned)
 u>   ( u1 u2 -- flag )  \ True if n1 > n2  (unsigned)
 <=   ( n1 n2 -- flag )  \ True if n1 <= n2  (signed)
 >=   ( n1 n2 -- flag )  \ True if n1 >= n2  (signed)
 
 \ IO ops
 io@  ( reg -- val )     \ read device register over io bus, 32-bit 
 io!  ( val reg -- )     \ write device register over io bus, 32-bit 
 
 \ Console IO
 . ( n -- )              \ output interger as text
 emit ( c -- )           \ output character by byte code
 cr ( -- )               \ output \n
 s" " ( -- )             \ define const string
 ." " ( -- )             \ output const string
 key ( -- n )            \ read character byte 
```

</details>

### Лексер и парсер

Для разработки лексера и парсера была создана библиотека,
документацию по внутреннему устройству см. [репозиторий](https://github.com/BardinPetr/lexer-parser).

Основа лексера - разбиение на токены по пробельным символам,
почти все слова forth преобразуются в единственный токен WORD,
так как в forth все операторы есть по сути вызов функции.
Отдельно обрабатываются определения функций и управляющие структуры.

Парсер сделан на основе парсер-комбинаторов,
и применяется в для разбора управляющих структур в абстрактное синтаксическое дерево,
по которому далее работает транслятор

Комментарии вида `\ text` и `( -- )` удаляются лексером

### Транслятор

Транслятор работает за один проход,
последовательно по дереву обходом в глубину транслируя слова forth
в объекты инструкций с необходимыми параметрами, а также разворачивая код в линейный последовательный вид.

Конструкции, на которые заменяются слова, определены в [базовой библиотеке](src/compiler/forthlib/stdlib.py),
там словам соотносятся последовательности инструкций. Допускается 2 вида преобразования - inline и call,
то есть либо замена сразу на последовательность инструкций, либо замена на вызов библиотечной функции.
Библиотека также есть основная часть транслятора, так как все определения введенные пользователем
дописываются туда к базовым и извлекаются единообразно.

Определения функций и переменных, располагаются во временной структуре (до момента линковки),
и для них создаются временные адреса расположения,
все команды с обращениями оборачиваются в специальный контейнер,
который будет при проходе линкером разворачиваться в обычную команду,
с релокацией адресов в соответствии с типом адресации.
Управляющие структуры разворачиваются с использованием условных и безусловных переходов,
с рассчитанными смещениями.

Транслятор разработан таким образом, минимально зависит от архитектуры машины,
и легко может быть доработан для других архитектур за счет замены базовой библиотеки.

Также есть препроцессор, позволяющий при помощи `\import`
встроить forth-код из другого файла в основной еще до начала работы лексера.

### Представление в памяти и линковка

На вход поступает основной код,
определения функций включая статически присоединенные библиотечные, а также статические переменные.
На выходе получается образ памяти, с расположенными в нем данными и инструкциями,
который затем будет скомпилирован в бинарный формат.

Исполняемый код и данные всегда выровнены по 32-битным словам, даже если занимают меньше.
Образ памяти представляет собой последовательность слов, включая данные и код, отличий в хранении кода и данных нет.
Образ загружается в память с адреса 0, исполнение начинается с адреса 0.

- основной код (то, что не в функциях)
    - размещается в образе последовательно начиная с адреса 0
- функции
    - размещаются в образе после основного кода последовательно
    - функции всегда сопровождаются инструкцией возврата, так как forth не подразумевает этого
    - вызовы функций линковщик связывает с относительными смещениями от адреса инструкции вызова до начала функции
- переменные (ячейки оперативной памяти)
    - создаются только статически в образе оперативной памяти, заполняются 0 или содержимым
    - размещаются в образе после кода всех инструкций последовательно
    - обращения к переменным линковщик статически заменяет на их абсолютные адреса в образе

Определение процесса линковки: [memory.linker](src/compiler/memory.py)

### CLI транслятора

```shell
$ ./src/compiler/main.py
  usage: main.py [-h] [-v] input_file output_file
  
  Forth parser & compiler
  
  positional arguments:
    input_file     Forth file path
    output_file    Output file for compiled binary
  
  options:
    -h, --help     show this help message and exit
    -v, --verbose  Print out detailed information on compilation process and precompiled non-binary code
```
