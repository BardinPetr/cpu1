### Исполнение микрокода

Микрокоманды исполняются последовательно из ПЗУ микрокода,
в зависимости от бита типа может присутствовать условный переход. Исполнение начинается с нулевого адреса.

Размер микрокоманды всегда 64 бит, но реально используется меньше:

- exec: _42 бит_
- jump: _55 бит_

Формат команд горизонтально-вертикальный, есть поддержка
групп сигналов с множественной активацией (кодируются 1 по биту на сигнал) и
с единичной активацией (кодируются по номеру для уменьшения объема).

Устройство управления по фронту тактового импульса загружает последовательно микрокоманды из ПЗУ,
по заднему фронту происходит либо инкремент MC_PC,
либо для микрокоманд ветвления сравнение шины C с условием перехода и добавление смещения к MC_PC.

Типы микрокоманд по представляемым возможностям:

- exec
    - чтение регистров
    - чтение памяти
    - АЛУ
    - запись регистров
    - запись памяти
    - управление IO
    - управление стеком
- jump
    - чтение регистров
    - чтение памяти
    - АЛУ
    - выполнение условного перехода в микрокоде
        - проверка происходит сравнением выбранного бита шины C с булевы значением в команде
        - переход по относительному смещению от MC_PC

Микрокод процессора расположен в [файле](src/machine/mc/code/main.mcasm).

Принцип работы микрокода:

- загрузка инструкции в CR
- инкремент IP
- последовательные проверками битов CR для определения команды по opcode
- исполнение микрокода команды

### Control unit

Состоит из 2х основных частей:

- MCSequencer
    - по сигналу тактирования загружает микрокоманды из памяти в `control_bus`
    - генерация тактирования для datapath
- набор декодеров (ALUDecoder, RegReadDecoder, RegWriteDecoder, StackDecoder)
    - выделение из `control_bus` сигналов на отдельные компоненты расписанные далее в соответствии с фронтом импульса

Основные сигналы управления:

| сигналы                                      | описание                          |
|----------------------------------------------|-----------------------------------|
| alu_ctrl                                     | оператор АЛУ                      |
| alu_ctrl_pa, alu_ctrl_pb                     | функции на входе в АЛУ            |
| alu_flag_ctrl, reg_ps_wr                     | установка флагов АЛУ, запись в PS |
| mux_bus_a_reg_in_ctrl, mux_bus_b_reg_in_ctrl | выбор источника для шин А и В     |
| r_stack_shift, r_stack_wr                    | сдвиги запись стека R             |
| d_stack_shift, d_stack_wr                    | сдвиги запись стека D             |
| demux_bus_c_reg_id                           | выбор получателя данных с шины C  |
| demux_bus_c_reg_wr                           | запись в получатель с шины С      |
| ram_a_wr                                     | выполнение записи в память        |

### Datapath

Основой процессора является АЛУ, которое подключено к системным шинам A, B - входным, и С - выходной.

При выполнении микрокоманды первый этап - по переднему фронту загрузка операндов в шины A, B,
для этого в соответствии с `mux_bus_*_reg_in_ctrl` ([BusInCtrl](src/machine/arch.py)) мультиплексируются в шины A и B
выходы регистров, значений со стека (по 2 верхних значения каждого стека выдаются всегда из модуля стека),
и из памяти (по переднему фронту в выходном регистре данных памяти всегда данные по адресу AR).

По заднему фронту защелкиваются защелки на входных шинах перед АЛУ,
его операция определяется `alu_ctrl` ([ALUCtrl](src/machine/arch.py)), при этом перед вычислением основной функции
над каждым операндом можно провести предварительно набор операций `alu_ctrl_p*` ([ALUPortCtrl](src/machine/arch.py)).

Далее все по заднему фронту, значение с шины С нужно демультиплексором
по `demux_bus_c_reg_id` ([BusOutCtrl](src/machine/arch.py)) передать
либо на входы регистров, либо на модули стеков, либо в КВУ.
Установка `demux_bus_c_reg_wr` позволяет выполнить запись в регистры,
`ram_a_wr` - в память (если в AR уже установлен адрес в прошлых команде и
в этой команде выход шины С выбран на регистр данных модуля памяти).
Сигналы `*_stack_wr` и `*_stack_shift` напрямую передаются модулям стека, о нем в следующем разделе.
АЛУ также выдает флаги, которые при установке `alu_flag_ctrl` и `reg_ps_wr` записываются в PS.

Основные сигналы данных:

| сигналы                   | описание                                                                      |
|---------------------------|-------------------------------------------------------------------------------|
| bus_*                     | шины A, B, C                                                                  |
| alu_*_in                  | входы с шин A, B с регистра перед АЛУ                                         |
| reg_\<name>_*             | сигналы входа, выхода и записи в регистр                                      |
| ram_data_in, ram_data_out | вход и выход данных с памяти                                                  |
| \<name>_stack_tos\<pos>   | выходы со стека \<name> верхнего (pos=0) или второго с верху (pos=1) значения |
| \<name>_stack_in          | вход данных в модуль стека \<name>                                            |
| io_ctrl_data_output       | выходной регистр данных КВУ                                                   |

### Функционирование модуля памяти

[Код модуля](src/machine/components/RAM.py).

По переднему фронту модуль выставляет на шину данных значение из памяти по адресу на шине адреса.

По заднему фронту модуль записывает в память значение
с шины данных по адресу на шине адреса при установке разрешающего сигнала.

### Функционирование модуля стека

[Код модуля](src/machine/components/ExtendedStack.py).

Выводы tos0, tos1 отображают 2 значения от вершины стека из регистрового файла при изменении указателя стека,
выводы full и empty соответственно показывают факт заполнения стека до максимума и его пустоту.

Сдвиг происходит при установке значения `in_shift` допускающего сдвиги +1, -1 и 0.
Запись в регистры проходит только в верх стек после сдвигов по заднему фронту при установленном `wr_top`.
