## Обзор архитектуры

### Исполнение микрокода

Микрокоманды исполняются последовательно из ПЗУ микрокода,
в зависимости от бита типа может присутствовать условный переход. Исполнение начинается с нулевого адреса.

Размер микрокоманды всегда 64 бит, но реально используется меньше:

- exec: _42 бит_
- jump: _44 бит_

Формат команд горизонтально-вертикальный, есть поддержка
групп сигналов с множественной активацией (кодируются 1 по биту на сигнал) и
с единичной активацией (кодируются по номеру для уменьшения объема).

Устройство управления по переднему фронту тактового импульса загружает последовательно микрокоманды из ПЗУ,
по заднему фронту происходит либо инкремент MC_PC,
либо для микрокоманд ветвления сравнение шины C с условием перехода и изменение MC_PC.

Типы микрокоманд по представляемым возможностям:

- exec
    - чтение регистров
    - чтение памяти
    - АЛУ
    - запись регистров
    - запись памяти
    - управление IO
    - управление стеком
- jump
    - чтение регистров
    - чтение памяти
    - АЛУ
    - выполнение условного перехода в микрокоде
        - проверка происходит сравнением выбранного бита шины C с булевы значением в команде
        - переход по абсолютному адресу

Микрокод процессора расположен в [файле](src/machine/mc/code/main.mcasm).

Принцип работы микрокода:

- загрузка инструкции по IP в CR
- инкремент IP
- последовательные проверками битов CR для определения команды по opcode
- исполнение микрокода команды

### Control unit

[Код модуля](src/machine/mc/components/control.py).

Состоит из 2х основных частей:

- MCSequencer
    - по переднему фронту тактирования загружает микрокоманды из памяти в `control_bus`
    - по заднему фронту тактирования меняет счетчик микрокоманд и делает переходы
    - генерация тактирования для datapath (на чтение и на запись)
- набор декодеров (ALUDecoder, RegReadDecoder, RegWriteDecoder, StackDecoder)
    - выделение из `control_bus` сигналов на отдельные компоненты расписанные далее в соответствии с фронтом импульса и
      последовательностью управления

Основные сигналы управления:

| сигналы                                      | описание                          |
|----------------------------------------------|-----------------------------------|
| alu_ctrl                                     | оператор АЛУ                      |
| alu_ctrl_pa, alu_ctrl_pb                     | функции на входе в АЛУ            |
| alu_flag_ctrl, reg_ps_wr                     | установка флагов АЛУ, запись в PS |
| mux_bus_a_reg_in_ctrl, mux_bus_b_reg_in_ctrl | выбор источника для шин А и В     |
| r_stack_shift, r_stack_wr                    | сдвиги запись стека R             |
| d_stack_shift, d_stack_wr                    | сдвиги запись стека D             |
| demux_bus_c_reg_id                           | выбор получателя данных с шины C  |
| ram_a_wr                                     | выполнение записи в память        |

### Datapath

[Код модуля](src/machine/datapath/datapath.py).

Основой процессора является АЛУ, которое подключено к системным шинам A, B - входным, и С - выходной.

При выполнении микрокоманды первый этап - по переднему фронту загрузка операндов в шины A, B,
для этого в соответствии с `mux_bus_*_reg_in_ctrl` ([BusInCtrl](src/machine/arch.py)) мультиплексируются в шины A и B
выходы регистров, значений со стека (по 2 верхних значения каждого стека выдаются всегда из модуля стека),
и из памяти (по переднему фронту в выходном регистре данных памяти всегда данные по адресу AR).

По заднему фронту защелкиваются защелки на входных шинах перед АЛУ,
его операция определяется `alu_ctrl` ([ALUCtrl](src/machine/arch.py)), при этом перед вычислением основной функции
над каждым операндом можно провести предварительно набор операций `alu_ctrl_p*` ([ALUPortCtrl](src/machine/arch.py)).

Далее все по заднему фронту синхроимпульса записи, значение с шины С нужно демультиплексором
по `demux_bus_c_reg_id` ([BusOutCtrl](src/machine/arch.py)) передать
либо на входы регистров, либо на модули стеков, либо в КВУ.
Установка `demux_bus_c_reg_wr` позволяет выполнить запись в регистры,
`ram_a_wr` - в память (если в AR уже установлен адрес в прошлых команде и
в этой команде выход шины С выбран на регистр данных модуля памяти).
Сигналы `*_stack_wr` и `*_stack_shift` напрямую передаются модулям стека, о нем в следующем разделе.
АЛУ также выдает флаги, которые при установке `alu_flag_ctrl` и `reg_ps_wr` записываются в PS.

Основные сигналы данных:

| сигналы                 | описание                                                                      |
|-------------------------|-------------------------------------------------------------------------------|
| bus_*                   | шины A, B, C                                                                  |
| alu_*_in                | входы с шин A, B с регистра перед АЛУ                                         |
| reg_\<name>_*           | сигналы входа, выхода и записи в регистр                                      |
| reg_drw_*, ram_drr      | входной и выходной регистр данных памяти                                      |
| \<name>_stack_tos\<pos> | выходы со стека \<name> верхнего (pos=0) или второго с верху (pos=1) значения |
| \<name>_stack_in        | вход данных в модуль стека \<name>                                            |
| io_ctrl_data_output     | выходной регистр данных КВУ                                                   |

### Функционирование модуля памяти

[Код модуля](src/machine/components/RAM.py).

По переднему фронту модуль выставляет на шину данных значение из памяти по адресу на шине адреса.

По заднему фронту модуль записывает в память значение
с шины данных по адресу на шине адреса при установке разрешающего сигнала.

### Функционирование модуля стека

[Код модуля](src/machine/components/ExtendedStack.py).

Выводы tos0, tos1 отображают 2 значения от вершины стека из регистрового файла при изменении указателя стека,
выводы full и empty соответственно показывают факт заполнения стека до максимума и его пустоту.

Сдвиг происходит при установке значения `in_shift` допускающего сдвиги +1, -1 и 0.
Запись в регистры проходит только в верх стек после сдвигов по заднему фронту при установленном `wr_top`.

### Схемы

Схемы сделаны при помощи ПО Logisim Evolution, проект прилагается.

Все логические компоненты напрямую отражаются в идентичные в коде модели.
На схемах представлены только основные модули системы, 
в частности, не присутствуют те, в которых для симуляции есть несинтезируемые операции из Python.
Сигналы на схемах заименованы в соответствии с моделью.

<details>

<summary>Схемы</summary>

#### Control unit

Загрузка микрокоманд и переходы

![ctrl_instr.png](media/Fctrl_instr.png)

Предварительное декодирование микрокоманды

![ctrl_in.png](docs/media/ctrl_in.png)

Декодеры управления стеком

![ctrl_stack.png](docs/media/ctrl_stack.png)

Декодеры управления памятью и регистрами

![ctrl_reg.png](docs/media/ctrl_reg.png)

#### Datapath

Основной вычислительный модуль, обвязка АЛУ

![dp_alu.png](docs/media/dp_alu.png)

Входной мультиплексор АЛУ (две симметричные схемы, в именах Х соответствует шине А или В)

![dp_mux.png](docs/media/dp_mux.png)

Базовые регистры и управление флагами PS

![dp_reg.png](docs/media/dp_reg.png)

Модуль памяти, его регистровая обвязка и модуль контроллера IO

![dp_mem.png](docs/media/dp_mem.png)

Модули стека

![dp_stack.png](docs/media/dp_stack.png)


</details>


