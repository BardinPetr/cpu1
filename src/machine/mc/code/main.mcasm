start:

# fetch instruction from RAM to CR, increase IP
infetch:
(IP ADD) -> AR;
(DR ADD) -> CR;
(IP(INC) ADD) -> IP;

# execute command according to opcode of CR[31:20]
exec:

# group select of CR[31:28]
switch (CR ADD)[30:28] {

  #GIOC
  case 0b000 {
    switch (CR ADD)[21:20] {
      # HLT # TODO
      case 0b00 { }
      # NOP
      case 0b01 { }
      # IN # TODO
      case 0b10 { }
      # OUT # TODO
      case 0b11 { }
    };
  }

  # GMTH
  case 0b001 {
    switch (CR ADD)[23:20] {
      # ADD
      case 0b0000 { (DSS ADD DST) poprep(D); }
      # SUB
      case 0b0001 { (DSS ADD DST(INC,NOT)) poprep(D); }
      # DIV
      case 0b0010 { (DSS DIV DST) poprep(D); }
      # MUL
      case 0b0011 { (DSS MUL DST) poprep(D); }
      # MOD
      case 0b0100 { (DSS MOD DST) poprep(D); }
      # AND
      case 0b0101 { (DSS AND DST) poprep(D); }
      # OR
      case 0b0110 { (DSS OR DST) poprep(D); }
      # INV (~x)
      case 0b0111 { (DST(NOT) ADD) rep(D); }
      # INC
      case 0b1000 { (DST(INC) ADD) rep(D); }
      # DEC
      case 0b1001 { (DST ADD Z(NOT)) rep(D); }
      # NEG (-x)
      case 0b1010 { (DST(NOT,INC) ADD) rep(D); }
    };
  }

  # GSTK
  case 0b010 {
    # (CR ADD)[16] is stack id (0=D, 1=R),
    # meaning is stack to operate on, or source stack for two-stack operation

    switch (CR ADD)[22:20] {
      # ISTKPSH
      case 0b0000 {
        if (CR ADD)[16] == 0  { (CR(TKW) ADD) push(D); }
        else                  { (CR(TKW) ADD) push(R); };
      }

      # STKMV src[a];dst[] -> src[];dst[a]   (ctrl/stackid is src)
      case 0b0001 {
        if (CR ADD)[16] == 0  { (DST ADD) push(R), pop(D); }
        else                  { (RST ADD) push(D), pop(R); };
      }

      # STKCP src[a];dst[] -> src[a];dst[a]   (ctrl/stackid is src)
      case 0b0010 {
        if (CR ADD)[16] == 0  { (DST ADD) push(R); }
        else                  { (RST ADD) push(D); };
      }

      # STKPOP [a] -> []
      case 0b0011 {
        if (CR ADD)[16] == 0  { (ZERO) pop(D); }
        else                  { (ZERO) pop(R); };
      }

      # STKDUP [a] -> [a, a]
      case 0b0101 {
        if (CR ADD)[16] == 0  { (DST ADD) push(D); }
        else                  { (RST ADD) push(R); };
      }

      # STKOVR [a,b] -> [a,b,a]
      case 0b0100 {
        if (CR ADD)[16] == 0  { (DSS ADD) push(D); }
        else                  { (RSS ADD) push(R); };
      }

      # STKSWP [a,b] -> [b,a]
      case 0b0110 {
        if (CR ADD)[16] == 0  {
          (DSS ADD) push(R);
          (DST ADD) poprep(D);
          (RST ADD) push(D), pop(R);
        } else {
          (RSS ADD) push(D);
          (RST ADD) poprep(R);
          (DST ADD) push(R), pop(D);
        };
      }
    };
  }

  # GCMP
  case 0b011 {
    (DSS ADD DST(NOT,INC)) push(D) set(Z,V,C,N);

#    switch (CR ADD)[21:20] {
#      # CEQ
#      case 0b00 {
#
#      }
#      # CLT
#      case 0b01 {  }
#      # CGT
#      case 0b10 {  }
#    };
  }

  # GJMP
  case 0b100 {

  }

  # GMEM
  case 0b101 {
    switch (CR ADD)[20:20] {
      # FETCH [addr] -> [val]
      case 0b0 {
        (DST ADD) -> AR;
        (DR ADD) rep(D);
      }

      # STORE [val,addr] -> []
      case 0b1 {
        (DST ADD) -> AR, pop(D);
        (DST ADD) -> DR, store, pop(D);
      }
    };
  }
};


end:

jmp start;
